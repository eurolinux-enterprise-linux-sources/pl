\chapter{Overview}

\product{}-\productversion{} is the first major release since the
introduction of user-defined classes.  We have decided to name it
such because the relation between the hosting Prolog system and
\product{} has been changed radically, important features for
the generation of stand-alone executables have been added, as well as
a powerful \class{table} class for manipulating tabular layout of
graphical objects.


The new host message-passing protocol is not only faster and uses less
memory, it also allows passing native host (Prolog) data over
\product{}-methods. In addition, a transparent protocol for representing
native (recorded) Prolog data in \product{} instance-variables has been
added. These features facilitate proper design of \product/Prolog
programs with far less hassle.	Defining graphical applications using
\product{} classes defined in Prolog is the accepted preferred mechanism
for structuring large GUI applications. Unfortunately however, as
\product{} methods, even when defined in Prolog, only accepted
\product{} data, either the native Prolog data had to be represented in
\product{} data or a predicate instead of a method-invocation must be
used. \Chapref{tree} provides an example of passing native Prolog data.

Graphical applications often require images, help-files and other data
that is not easily expressed in Prolog source-code.
\product{}-\productversion{} provides a generic mechanism for
associating this data with the application.  See \chapref{resources}.


Tables are a common and well understood mechanism for defining
2-dimensional layout. \product{}-\productversion{} provides tables
modelled after HTML-3, including row and column-spanning, defining rules
and frames, spacing and manipulation mechanisms such as naming columns
and rows, deleting, inserting and sorting rows, etc. See
\chapref{layout}.


\chapter{Changes to Message Passing}

\section{Allow for Prolog-native data}

In earlier versions, sending a message was realised by resolving the
implementation, and activating it.  In the new version a \jargon{goal}
is created, after which actions on this goal resolve the implementation
and its type-vector, type-check and allocate the arguments and finally
execute the implementation.  The advantage of this is two-fold.  First
of all, it allows the host-interface to check whether the implementation
called is actually defined in the host-language itself.  In this case
the interface can decide not to route the call through \product{}, but
instead	build the proper argument vector an call the implementation
directly.  This is faster and, at least equally important, it avoids the
requirement to represent all data passed over a \product{} method, even
when implemented in the host to be converted into \product{} data.
Second, the new implementation technique results in a much flatter and
smaller C-stack.  Not only this saves a considerable amount of memory
in deeply nested method-invocation, but it also reduces the amount
of stack-faults on processors using \jargon{register-windows} (e.g.\
\index{SPARC}SPARC)

To improve the Prolog integration even further, the class
\class{prolog_term} and type \type{prolog} have been introduced. When
invoking Prolog-defined methods, the type \type{prolog} indicates the
interface that the Prolog argument should be passed directly to the
implementation. If a \product{}-native argument is defined to be of type
\type{prolog}, the Prolog term-reference is packed into an instance of
the class \class{prolog_term}. If the context in which a prolog_term
object was created terminates and the object has references, the
interface will record the term into the Prolog database.

This approach results in natural behaviour. If a Prolog term is passed
over methods that allow for it and reaches Prolog at some stage, Prolog
receives the unmodified term. If the Prolog term is associated with a
\product{} object, normally as data for an instance-variable, the
instance-variable will contain a recorded copy of the term. If Prolog
requests the value of this term, the term is copied back to the Prolog
stacks (cf.\ recorded/3).


\subsection{Example --- Creating a tree from Prolog data} \label{sec:tree} 

Suppose a tree is represented in Prolog using the term
\term{node}{Value, Sons}, where \arg{Sons} itself is a tree and
\arg{Value} is an arbitrary Prolog term. We would like to represent this
tree using a \product{} \class{tree} object. If a node is selected, the
associated term is displayed.

\input{tree.tex}

\postscriptfig{parsetree}{Resulting window for ?- showtree.}

\subsection{Prolog terms and type any}

The features described in this section have been added to \product{} in
version 5.1.

The \product{} type any refers to `anything but functions'. It is only natural
that this includes Prolog terms.  However, the interface says that the
goal below creates a chain holding a point object and not a chain
holding a Prolog term:

\begin{code}
?- new(Ch, chain(point(1,2))).
\end{code}

This ambiguity is fixed using a \funcref{prolog}{1} term.  A term of
the form \exam{prolog(...)} is translated into a \class{prolog_term}
object it is not atomic.  The prolog_term instance however is marked
such that the type-check for \type{any} accepts it.  This constructs
allow for passing Prolog terms through any method argument typed as
\type{any}. Useful examples are storing Prolog terms in \product{}
\class{vector} objects, associating Prolog data to objects using
`object->attribute' (see below), etc.

\begin{code}
	...
	send(Object, attribute, list, [this, is, a, list]),
	...,
	get(Object, attribute, list, List),
	...
\end{code}


\section{The predicates send/2 and get/3}

\product{} now supports two formats for the send- and get-predicates.
The principle format has been changed to:

\begin{quote}
\term{send}{Receiver, Selector(...Arg...)} \\
\term{get}{Receiver, Selector(...Arg...), Answer} \\
\end{quote}

For example:

\begin{code}
?- send(new(P, picture), open),
   send(P, display(box(100,100), point(10,10))).
\end{code}

Advantages of this representation are:

\begin{itemize}
    \item No limits to the number of arguments.
    \item Generally easier specification of utility-predicates
          that wrap around the \product{} primitives as messages are
	  represented using single Prolog term.
    \item Possibility to define (efficiently) other syntaxes
          for \product{}.%
	\footnote{Using an infix-operator for send/2, we could
		  express send using \arg{Receiver} op \arg{Message}.
		  Unfortunately it is not easy to find a good
		  operator.  {\tt ->} is already reserved,
		  {\tt .} (dot) creates too much confusion
		  with the final dot of a Prolog clause (a
		  space after it would make the parser think
		  the clause has ended).  Suggestions are
		  welcome!}
\end{itemize}

As a disadvantage, \product{} produces more Prolog garbage, but using
modern compilers, this is unlikely to be a problem.

\paragraph{The old syntax} is still acceptable.  When appearing
as a normal subclause, the \product{} term-expansion will automatically
rewrite it.  Actual calls are modified at runtime.

\section{Invoking behaviour on the super-class}		\label{sec:sendsuper}

Invoking behaviour on the super-class is implemented completely
different. In the old system, send(\arg{Object}, send_super, selector, ...)
was used. In the new system, the primitive send_class/2 is used and
application programmers use send_super/2 with the same syntax as send/2.

The construct send_super/2 is translated by the \product{} term-expansion
module into a proper send_class/2 message. All variations are
recognised:

\begin{quote}
\term{send}{Receiver, send_super, Selector, ...} \\
\term{send}{Receiver, send_super(Selector, ...)} \\
\term{send_super}{Receiver, Selector, ...} \\
\term{send_super}{Receiver, Selector(...)} \\
\end{quote}

\paragraph{Some incompatibilities} arise from this:  dynamically built
invocations of the old send-super construct will fail, as will calls
outside the context of a class.  If the message invoked from the
super-class is determined dynamically, the code below should
be used, i.e.\ the \jargon{message} should be constructed dynamically,
not the \jargon{goal}.

\begin{code}
...,
Msg =.. [Selector|Arguments],
send_super(Receiver, Msg),
...,
\end{code}

\section{Variable-argument methods}		\label{sec:vararg}

\product{} methods dealing with variable-argument parameter lists use
different passing rules.  Instead of passing the arguments packed
in a \class{vector} object, they are now passed as a Prolog list.

The example below redefines `label ->report' to change the colour of
the text according to the nature of the message:

\begin{code}
:- pce_begin_class(reporter, label).

initialise(R) :->
	send_super(R, initialise, reporter, '').

report(R, Kind:name, Fmt:name, Args:any ...) :->
	colour(Kind, Colour),
	send(R, colour, Colour),
	Msg =.. [report, Kind, Fmt | Args],
	send_super(R, Msg).

colour(status, green).
colour(error,  red).
colour(_,      black).

:- pce_end_class.
\end{code}

\paragraph{These incompatibilities} are generally easily found by
scanning the source for \verb$...$. There is no automatic rewrite
feasible.

\chapter{Class-variables}

The \product{}-4 notion of resources, expressing user-defaults, has been
replaced by the notion of class-variables, the default of which can
be read from the \product{} \file{Defaults}-file and/or the user's
\file{\$HOME/.xpce/Defaults} file.

The notion `resource' is now reserved for `program resources', data
required by the program that cannot (easily) be expressed in the
program itself.  See \chapref{resources}.

\section{Consequences for the application programmer}

For the application-programmer, the class-expression

\begin{quote}
\term{resource}{Name, Type, String-ified-default [, Comment]}.
\end{quote}

is replaced by

\begin{quote}
\term{class_variable}{Name, Type, Default [, Comment]}.
\end{quote}

Please note that the default is no longer the string-ified version
of the value, but the value itself.

The method `object <-resource_value' has been replaced by
`object <-class_variable_value'.  In addition, class variables provide
normal get-behaviour, scheduled after methods and instance-variables,
and the value of a class-variable can thus be retrieved using a normal
get-operation.

If both a instance- and a class-variable exist with the same name, the
instance-variable is initialised to @class_default.  On first access,
the value of the class-variable is used to fill the instance-variable.
The code-fragment below illustrates this:

\begin{code}
:- pce_begin_class(classvar_demo, object).

variable(count, int, get).
class_variable(count, int, 25).

...

show_count(CVD) :->
	get(CVD, count, Count),
	send(@display, inform, 'Count = %d', Count).

\end{code}


\subsection{The 'compatibility/resource' library}

The \pllib{'compatibility/resource'} defines additional pre-processing
and methods to deal with commonly used programming constructs of the old
resource mechanism.

This library reports class-variable (resource) values with incompatible
syntax (string-ified) and can be used to maintain source code that
should run both on older versions as on \product{}-\productversion{}. In
the latter case, execute the following directive in the context of the
\module{user} module:

\begin{code}
:- (   get(@pce, version, number, Version),
       Version >= 50000
   ->  use_module(library('compatibility/resource'))
   ;   true
   ).
\end{code}

Please note that when using this library, resources as defined in
\chapref{resources} cannot appear inside a class-definition.


\section{Consequences for the end-user}

\product{} no longer uses the X11 resource-syntax.  The syntax for a
class-variable default value is defined as:

\begin{quote}
<class>.<class-variable>: <value>
\end{quote}

Thus, the leading \const{Pce.} has been dropped and class-names are
written in exact-case rather then capitalised.  The value-syntax has
not been changed.

The system defaults-file is located in \file{\$PCEHOME/Defaults},
where \$PCEHOME refers to the \product{} home-directory (see
`@pce <-home'). The user's defaults-file is located in
\file{\$HOME/.xpce/Defaults}, which is achieved using an
include-statement at the end of the system-defaults file.


\chapter{Program resources}			\label{sec:resources}

Resources, in the new sense of the word is data that is required by
an application but cannot be expressed easily as program-code.  Examples
are image-files, help-files, and other files using non-Prolog syntax.
Such files are declared by defining clauses for the predicate
resource/3:

\begin{description}
    \predicate{resource}{3}{?Name, ?Class, ?PathSpec}
Define the file specified by \arg{PathSpec} to contain data for the
resource named \arg{Name} of resource-class \arg{Class}.

\arg{Name} refers to the logical name of the resource, which is
interpreted locally for a Prolog module.  Declarations in the module
\module{user} are visible as defaults from all other modules.
\arg{Class} defines the type of object to be expected in the file. Right
now, they provide an additional name-space for resources. \arg{PathSpec}
is a file specification as acceptable to absolute_file_name/[2,3].
\end{description}

Resources can be handled both from Prolog as for \product{}.  From
Prolog, this is achieved using open_resource/3:

\begin{description}
    \predicate{open_resource}{4}{+Name, ?Class, -Stream}
Opens the resource specified by \arg{Name} and \arg{Class}.  If the
latter is a variable, it will be unified to the class of the first
resource found that has the specified \arg{Name}.  If successful,
\arg{Stream} becomes a handle to a binary input stream, providing
access to the content of the resource.

The predicate open_resource/3 first checks resource/3.  If successful
it will open the returned resource source-file.  Otherwise it will look
in the programs resource database.  When creating a saved-state, the
system saves the resource contents into the resource archive,
but does not save the resource clauses.

This way, the development environment uses the files (and modifications
to the resource/3 declarations and/or files containing resource info
thus immediately affect the running environment, while the runtime
system quickly accesses the system resources.
\end{description}

From \product{}, resources are accessed using the class
\class{resource}, which is located next to \class{file} below the
common data-representation class \class{source_sink}.  Many of the
methods that require data accept instances of \class{source_sink},
making resources a suitable candidate.

Below is the preferred way to specify and use an icon.

\begin{code}
resource(my_icon,	image,	image('my_icon.xpm')).

	...,
	send(Button, label, image(resource(my_icon))),
	...,

\end{code}

The directive pce_image_directory/1 adds the provided directory to the
search-path for images (represented in the class-variable
\classvar{image}{path}), as well as to the \functor{image}{1} definition
of file_search_path/2.

Please note that MS-Windows formatted image files can currently not
be loaded through \class{resource} objects. The Windows API only
provides functions to extract these objects from a single file, or
nested as Windows resources in a \fileext{dll} or \fileext{exe} file.

Right now, it is adviced to translate the images into \fileext{xpm}
format using the following simple command:

\begin{code}
?- send(image('myicon.ico'), save, 'myicon,xpm', xpm).
\end{code}

This transformation is complete as the XPM image format covers all
aspects of the Microsoft image formats.


\chapter{Errors and Prolog exceptions}		\label{sec:errors}

\product{}-\productversion{} provides a mapping between \product{}
errors and Prolog exceptions.  For this reason a new `error <->feedback'
has been defined: \const{throw}. If an error is raised using
`object->error' that has <-feedback: \const{throw} and the system finds
a \jargon{goal} on the stack that indicates it is willing to catch
errors, the error details are stored in the goal. As control is returned
to Prolog, the interface maps the error details onto a Prolog exception.
This exception is of the format:

\begin{quote}
\term{error}{\term{pce}{ErrorId, ListOfArguments}, Context}
\end{quote}

This error can be catched using the ISO catch/3 construct:

\begin{code}
?- catch(send(@pce, not_implemented), E, true).

E = error(pce(no_behaviour,
	      [@pce/pce,  (->), not_implemented]),
	  send(@pce/pce, not_implemented))
\end{code}

This error-term can be printed using print_message/2.  The method
`error<-format' may also be used to map the error into a
\product{}-string:

\begin{code}
error_string(ErrorId, Args, TextAsAtom) :-
	Msg =.. [format|Args],
	get(error(ErrorId), Msg, String),
	get(String, value, TextAsAtom).
\end{code}

The \product{} manual's error browser can be used to examine the defined
error types.

\chapter{Modified and deleted features}

\section{Constraints --- only automatic for graphicals}

In practice, constraints are almost exclusively used to specify geometry
relations between graphical objects. Until now, constraints were
evaluated whenever a send-message was successfully executed. In
\productversion{}, constraints are executed automatically if the
geometry of a graphical object changes.  All other case should be 
invoked manually using `object ->update_constraints'.

If other objects are known to dependent using constraints on one or
more attributes of a class, it is advised to write a wrapper that
invokes ->update_constraints whenever the relevant attributes of the
object are modified.

For example, suppose a class \class{lamp} has been defined with a
property `is_on'.  The application uses constraints to propagate the
consequences of this property.  The lamp should be defined according
to the skeleton below:

\begin{code}

:- pce_begin_class(lamp, bitmap).

variable(is_on, bool := @off, get, "Whether the lamp is on/off").

is_on(L, OnOff:bool) :->
	send(L, slot, is_on, OnOff),
	send(L, update_constraints).

\end{code}


\section{Debugging and goal-stack examination}

The class \class{vmi} and its instances @vmi_send, @vmi_get, @vmi_new
and @vmi_free are deleted.  With this, `vmi->parent_goal', a method
to validate some goal is executing higher in the goal-stack has been
deleted too. Applications using these constructs should take alternative
measures.

The extensive debugger available in previous versions proved of little
practical usage. As of version \productversion{}, the debugger is
limited to tracing the activation of methods and the access to
instance-variables, as well as breaking (like Prolog \jargon{spy}) on
them. A break-point may be used to examine that status and stack-context
when a method is invoked.

The interface for setting break- and trace-point is the same, using
spypce/1 and tracepce/1.

\section{Edit interface}

The predicate editpce/1 has been replaced by a hook into the generic
edit/1 predicate.  This hook provides the following functionality:

\begin{description}
    \infixop{\tt->}{ClassOrObject}{Method}
Specifies a send-method.  Either \arg{Class} or \arg{Method} can be a
variable.
    \infixop{\tt<-}{ClassOrObject}{Method}
Specifies a get-method.  Either \arg{Class} or \arg{Method} can be a
variable.
    \termitem{Class}{}
In addition to the predefined objects, \product{}-classes of this
name are returned.
\end{description}

Example:

\begin{code}
?- edit(_->update).
Please select item to edit:

  1 q_agenda->update            boot('inferui.pl'):455
  2 toc_rule_node->update       boot('inferui.pl'):543
  3 btext_item->update          boot('lib/bitem.pl'):41

Your choice?
\end{code}

\chapter{Layout Managers}			\label{sec:layout}

A \jargon{Layout Manager} is an object that is associated with a
graphical \class{device} and which deals with managing the layout of the
graphicals displayed on the device. Layout-managers can either
manipulate the graphicals on the device directly, or it can attach
a \class{layout_interface} object to each the graphicals managed.  The
\class{layout_interface} object contains data required by the layout
manager about the layout properties of the graphical object.

In addition to managing the layout, layout_managers can provide hooks to
paint the background of a device, as well as to direct events.

In the future, layout-managers will form a hierarchy with a role similar
to the recogniser hierarchy. Currently the interface is only used by
class \class{table}, using \class{table_cell} as a refinement of
\class{layout_interface}.


\section{Graphical tables}

The most important graphical modification is the introduction of class
\class{table}, defining graphical tables modelled after HTML-3 tables.
The relevant classes are listed in the partial class-hierarchy below:

\postscriptfig{tabletree}{Location in the hierarchy of the
			  table-classes}

\section{Example --- Show contents of a directory in a table}

\input{showdir.tex}

\postscriptfig{showdir}{Resulting window for ?- show_directory('.').}


\chapter{Reference pages}

Below is the reference documentation for the modified \product{}/Prolog
interface.  This material will shortly be merged into ``Programming in
\product{}/Prolog''.

\section{Interface predicates}

In all definitions below, \arg{Message} is either an atom or a compound
term. The functor-name (or the atom) of the message denotes the
\jargon{selector} for the behaviour addressed. The arguments of a
compound \arg{Message} are used to build the argument vector for the
goal.

The following steps are executed when sending a message using any
of these predicates:

\begin{enumerate}
    \item Convert the \arg{Object} argument into a reference to a
          \product{} object.
    \item Extract the \jargon{selector} from the \arg{Message} and
    	  resolve the \jargon{implementation} of the behaviour denoted
	  by the combination of the object and \arg{selector}. This
	  process can yield a new receiving object, either due to
	  function-evaluation if the receiving object is a function
	  and behaviour is not defined on the function itself, or due
	  to \jargon{delegation}.
    \item Determine a description (a vector of \class{type} objects)
	  of the arguments required by the implementation.
    \item Allocate and fill the actual argument vector.  This process
          deals with named arguments (\infixterm{:=}{Name, Value}),
	  type-conversion as well as filling non-specified default
	  arguments.

	  The interface here already discriminates between \product{}
	  implemented behaviour from Prolog implemented.  In the first
	  case the argument vector is an array of native \product{}
	  data. If an argument accepts Prolog native data, the argument
	  is translated into an instance of class \class{prolog_term},
	  providing a handle to the Prolog term.  In the second case,
	  it creates a vector of Prolog term references for creating
	  the call to pce_principal:send_implementation/3 or
	  pce_principal:get_implementation/4.
    \item Execute the implementation by calling a \product{} interface
          function if the implementation is in \product{}, or by calling
	  the Prolog implementation directly.
    \item If it concerns a get-operation, convert the return value to
          the proper type.
    \item Discard all garbage object created in this process, except for
	  the return-value of a get-operation.
\end{enumerate}

\begin{description}
    \predicate{send}{2}{+Object, :Message}
Send \arg{Message} to the indicated \arg{Object}. In general, a
send-operation is intented to modify an object or test the object for
some property.  This predicate either succeeds or fails if it concerns
a test which fails.  If an error is encountered, the error is reported
to the GUI or the terminal or mapped onto a Prolog exception.  See
\secref{errors} for details.
    \predicate{send_class}{3}{+Object, +Class, :Message}
As send/2, but the implementation is resolved only considering methods
defined at the level of the specified \arg{Class} or higher in the
inheritence hierarchy.

This can be used in very special cases if one wants to force the usage
of a particular implementation. It is dangerous as assumptions made in
classes between the actual object-class and \arg{Class} may be violated.

Normally, send_super/2 should be used, which is mapped to a proper call
of send_class/3 by the class-compiler.
    \predicate{send_super}{2}{+Object, :Message}
This actually is not a predicate, but syntactic sugar translated by the
\product{} class-compiler into an appropriate send_class/3 call.  This
construct can only appear in the context of a method-definition.  It is
good practice that any method being refined in a sub-class invokes the
implementation of its super-class at some stage, as this guarantees no
assuptions made in the super-class are violated.  For example, if a 
subclass of class \class{device} is defined to realise a specific
graphical object, it {\bf must} invoke \term{send_super}{Dev,
initialise} in its refined ->initialise method before it displays any
\class{graphical} object on the device:

\begin{code}
:- pce_begin_class(my_graphical, device).

initialise(MG) :->
	send_super(MG, initialise),
	send(MG, display(box(100, 50))),
	...
\end{code}
    \predicate{get}{3}{+Object, :Message, -Answer}
Similar to send/2, but get-behaviour returns a value. The following
cases require attention.

\begin{itemlist}
    \item[A fresh `attribute' object is returned]
For example, `box<-size' returns and instance of class \class{size},
representing the current size of the box object.  This size object has
no relation to its creator and may be modified freely.  It need not
be discarded as the incremental garbage collector will deal with it if
the object is not protected using ->lock_object or by associating it
to another object.
    \item[An `attribute' is returned]
Unlike `box<-size', `box<-area' returns an instance of class
\class{area} describing the area of the box in the coordinate system of
its <-device, but the area object returned is a filler for the
`graphical <-area' instance-variable of the box object. Modifying this
area will leave the box and its <-device in an inconsistent state.
    \item[A normal fresh object is returned]
Some get-behaviour creates a new, completely independent instance
ready and intended for further manipulation.  This case is from the
programmers point of view no different from the return of a `fresh'
attribute object.
    \item[A fully functional part is returned]
If a device is, using `device<-member', asked for the object-reference
of a displayed graphical object, the returned object may be modified
freely as graphicals knon on what device they are displayed and will
inform this device of any relevant information, including the death
of the graphical.  Whether or not such a relation exists can only be
found in the documentation.  In general, if built-in objects are aware
of each others existence, they will inform each other.
\end{itemlist}
    \predicate{get_class}{4}{+Object, +Class, :Message, -Answer}
The predicate get_class/4 is what send_class/3 is for get-behaviour.
    \predicate{get_super}{2}{+Object, :Message, -Answer}
The predicate get_super/3 is what send_super/2 is for get-behaviour.
\end{description}


\subsection{Alternative interface predicates}

Both for compatibility reasons as because it will remain the preferred
syntax for some users, the predicates send/[3-12] and get/[4-13] are
defined:

\begin{description}
    \predicate{send}{3-12}{+Object, :Selector, ... +Arg ...}
Equivalent to \term{send}{Object, Selector(...Arg...)}.  The \product{}
macro-expansion translates these calls to send/2.  The predicates are
defined as well to deal with invocation through meta-predicates that
is not captured by the macro-expansion.  The following two calls are
fully identical:

\begin{code}
	send(Window, display(box(100, 50), point(10, 10))),
	send(Window, display, box(100, 50, point(120, 10))).
\end{code}

Note however that the existence of send/2 makes the following valid
code:

\begin{code}
	send_list(Window,
		  [ border(1),
		    background(green),
		    display(box(100,100), point(10,10))
		  ])
\end{code}
    \predicate{get}{4-13}{+Object, :Selector, ... +Arg ..., -Answer}
These predicates are handled as send/[3-12].
\end{description}


\chapter{Status, discussion and plans}

\section{Prolog interface}

\product{}-5.0.0 is primarily an evaluation release for the new
\product{}/Prolog interface. Except for the issues noted in these
release notes (especially \chapref{migrate}), old code is supposed to be
fully compatible with the new release. With this beta release we want to
access this claim, as well as your opinion on the direction chosen with
the interface.

One issue is whether to allow Prolog data (\class{prolog_term}) in more
places by including them into type \type{any}. This would make the
association of Prolog data with \product{} objects without user-defined
classes possible, but it would harm compatibility and possibly make the
intention of source-code less obvious.  Consider:

\begin{code}
?- new(Chain, chain(point(1, 2))).
\end{code}

If \type{any} accepts Prolog data, this will be a chain object holding
a Prolog term.  Translation into a point-object will only take place
at the moment a type is requested that does not accept
\class{prolog_term}.  This implies translation may take place multiple
times, resulting in multiple point instances being created from the same
term.

Alternatively, it would be possible to define a class, say
\class{term}, that is a normal subclass of class \class{object}
and contains a single slot holding the \class{prolog_term} object, so
a Prolog term can be stored in a chain using

\begin{code}
?- new(Chain, chain(term(point(1, 2)))).
\end{code}

Conversion back to Prolog could be achieved automatically (as with
the classes \class{real} and \class{prolog_term}, or by hand using
a method `term <-value'.  Comments?


\section{Tables}

Graphical tables have been tested quite extensively on a couple of
applications now. The basic functionality is stable, but both new
functionality (scrolling column/row subregions, 3D look) and utility
functions will be added. Suggestions are welcome.


\appendix
\chapter{Migrating old source code}		\label{sec:migrate}

This section provides a brief overview of things to check when migrating
existing code to \product{}-\productversion{}.


\begin{itemlist}
    \item[Resources]
If an application uses resources in user-defined classes, there are two
options. One is to load \pllib{'compatibility/resource'}, the other is
to do a global replace of the term \const{resource} into
\const{class_variable}. Values are represented using the normal
object-notation. The compatibility package will warn for possible
problems. The advised route therefore it to use the compatibility
package first, fix the value-notation and finally replace
\const{resource} with \const{class_variable}. See \chapref{resources}.
    \item[Variable-argument methods]
Argument are passed as a Prolog list, rather then a \class{code_vector}
instance.  In general forwarding is implemented by using Prolog univ
(=../2) to create a message and then calling send/2 or send_super/2.
Commonly, such constructs are found using \program{grep} for
the pattern \verb$...$., possibly \verb$"... *) *:"$ See \chapref{vararg}.
    \item[Send super]
Send/Get super cannot be used outside the context of a class. The
compiler will warn if it encounters a send-super call for which it
cannot resolve the context class. This problem has to be fixed manually.
See \chapref{sendsuper}.
\end{itemlist}

Finally, if the generation of a runtime is desirable, it is advised to
use the new-style resources to declare and access your images and other
program resources.

